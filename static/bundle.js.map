{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./main.js","webpack:///./main.sass?b77d","webpack:///./node_modules/instantclick/dist/instantclick.js","webpack:///./node_modules/loading-attribute-polyfill/loading-attribute-polyfill.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAoB;AAC6C;;AAEjE;AACA;AACA,2CAA2C,iBAAiB;AAC5D;AACA;AACA;AACA;;AAEuC;AACvC,mDAAY;AACZ;AACA;AACA;AACA,iCAAiC,iCAAiC;AAClE;AACA;AACA;AACA;;;;;;;;;;;;ACpBA,yC;;;;;;;;;;;ACAA;AACA,CAAC,KAA4D;AAC7D,CAAC,SACiC;AAClC,CAAC,qBAAqB;;AAEtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,wCAAwC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,6BAA6B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2DAA2D;AAChF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,+DAA+D;AACpF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,gCAAgC;AAC/C;AACA;;AAEA,eAAe,iCAAiC;AAChD;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,uCAAuC;AAC5D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,4BAA4B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oDAAoD;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,+DAA+D;AAClF;AACA;AACA;AACA,qBAAqB,kEAAkE;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAA6C;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS;;AAEhB;AACA;;AAEA;AACA,2EAA2E;AAC3E,0CAA0C,4BAA4B,EAAE;AACxE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;;AAEA,CAAC;;;;;;;;;;;;ACr9BD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,GAAG;;AAEH;AACA,4CAA4C;AAC5C;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA,kDAAkD;AAClD;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kDAAkD;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./main.js\");\n","import './main.sass'\nimport 'loading-attribute-polyfill/loading-attribute-polyfill.js'\n\nvar links = document.getElementsByTagName(\"a\");\nvar sites = ['yourlabs.org', 'yourlabs.fr', window.location.hostname]\nfor (var i = 0, linksLength = links.length; i < linksLength; i++) {\n   if (sites.indexOf(links[i].hostname) < 0) {\n      links[i].target = '_blank';\n   }\n}\n\nimport InstantClick from 'instantclick'\nInstantClick.init()\nvar dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);\nvar doNotTrack = (dnt == \"1\" || dnt == \"yes\");\nif (!doNotTrack) {\n\twindow.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;\n\tga('create', 'UA-169189134-1', 'auto');\n\tga('set', 'anonymizeIp', true);\n\tga('send', 'pageview');\n}\n","// removed by extract-text-webpack-plugin","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.InstantClick = factory());\n}(this, (function () { 'use strict';\n\n/* InstantClick 3.1.0 | (C) 2014-2017 Alexandre Dieulot | http://instantclick.io/license */\n\nvar instantclick;\nvar InstantClick = instantclick = function(document, location, $userAgent) {\n  // Internal variables\n  var $currentLocationWithoutHash\n    , $urlToPreload\n    , $preloadTimer\n    , $lastTouchTimestamp\n    , $hasBeenInitialized\n    , $touchEndedWithoutClickTimer\n    , $lastUsedTimeoutId = 0\n\n  // Preloading-related variables\n    , $history = {}\n    , $xhr\n    , $url = false\n    , $title = false\n    , $isContentTypeNotHTML\n    , $areTrackedElementsDifferent\n    , $body = false\n    , $lastDisplayTimestamp = 0\n    , $isPreloading = false\n    , $isWaitingForCompletion = false\n    , $gotANetworkError = false\n    , $trackedElementsData = []\n\n  // Variables defined by public functions\n    , $preloadOnMousedown\n    , $delayBeforePreload = 65\n    , $eventsCallbacks = {\n        preload: [],\n        receive: [],\n        wait: [],\n        change: [],\n        restore: [],\n        exit: []\n      }\n    , $timers = {}\n    , $currentPageXhrs = []\n    , $windowEventListeners = {}\n    , $delegatedEvents = {};\n\n\n  ////////// POLYFILL //////////\n\n\n  // Needed for `addEvent`\n  if (!Element.prototype.matches) {\n    Element.prototype.matches =\n      Element.prototype.webkitMatchesSelector ||\n      Element.prototype.msMatchesSelector ||\n      function (selector) {\n        var this$1 = this;\n\n        var matches = document.querySelectorAll(selector);\n        for (var i = 0; i < matches.length; i++) {\n          if (matches[i] == this$1) {\n            return true\n          }\n        }\n        return false\n      };\n  }\n\n\n  ////////// HELPERS //////////\n\n\n  function removeHash(url) {\n    var index = url.indexOf('#');\n    if (index == -1) {\n      return url\n    }\n    return url.substr(0, index)\n  }\n\n  function getParentLinkElement(element) {\n    while (element && element.nodeName != 'A') {\n      element = element.parentNode;\n    }\n    // `element` will be null if no link element is found\n    return element\n  }\n\n  function isBlacklisted(element) {\n    do {\n      if (!element.hasAttribute) { // Parent of <html>\n        break\n      }\n      if (element.hasAttribute('data-instant')) {\n        return false\n      }\n      if (element.hasAttribute('data-no-instant')) {\n        return true\n      }\n    }\n    while (element = element.parentNode)\n    return false\n  }\n\n  function isPreloadable(linkElement) {\n    var domain = location.protocol + '//' + location.host;\n\n    if (linkElement.target // target=\"_blank\" etc.\n        || linkElement.hasAttribute('download')\n        || linkElement.href.indexOf(domain + '/') != 0 // Another domain, or no href attribute\n        || (linkElement.href.indexOf('#') > -1\n            && removeHash(linkElement.href) == $currentLocationWithoutHash) // Anchor\n        || isBlacklisted(linkElement)\n       ) {\n      return false\n    }\n    return true\n  }\n\n  function triggerPageEvent(eventType) {\n    var argumentsToApply = Array.prototype.slice.call(arguments, 1)\n      , returnValue = false;\n    for (var i = 0; i < $eventsCallbacks[eventType].length; i++) {\n      if (eventType == 'receive') {\n        var altered = $eventsCallbacks[eventType][i].apply(window, argumentsToApply);\n        if (altered) {\n          // Update arguments for the next iteration of the loop.\n          if ('body' in altered) {\n            argumentsToApply[1] = altered.body;\n          }\n          if ('title' in altered) {\n            argumentsToApply[2] = altered.title;\n          }\n\n          returnValue = altered;\n        }\n      }\n      else {\n        $eventsCallbacks[eventType][i].apply(window, argumentsToApply);\n      }\n    }\n    return returnValue\n  }\n\n  function changePage(title, body, urlToPush, scrollPosition) {\n    abortCurrentPageXhrs();\n\n    document.documentElement.replaceChild(body, document.body);\n    // We cannot just use `document.body = doc.body`, it causes Safari (tested\n    // 5.1, 6.0 and Mobile 7.0) to execute script tags directly.\n\n    document.title = title;\n\n    if (urlToPush) {\n      addOrRemoveWindowEventListeners('remove');\n      if (urlToPush != location.href) {\n        history.pushState(null, null, urlToPush);\n\n        if ($userAgent.indexOf(' CriOS/') > -1) {\n          // Chrome for iOS:\n          //\n          // 1. Removes title in tab on pushState, so it needs to be set after.\n          //\n          // 2. Will not set the title if it's identical after trimming, so we\n          //    add a non-breaking space.\n          if (document.title == title) {\n            document.title = title + String.fromCharCode(160);\n          }\n          else {\n            document.title = title;\n          }\n        }\n      }\n\n      var hashIndex = urlToPush.indexOf('#')\n        , offsetElement = hashIndex > -1\n                     && document.getElementById(urlToPush.substr(hashIndex + 1))\n        , offset = 0;\n\n      if (offsetElement) {\n        while (offsetElement.offsetParent) {\n          offset += offsetElement.offsetTop;\n\n          offsetElement = offsetElement.offsetParent;\n        }\n      }\n      if ('requestAnimationFrame' in window) {\n        // Safari on macOS doesn't immediately visually change the page on\n        // `document.documentElement.replaceChild`, so if `scrollTo` is called\n        // without `requestAnimationFrame` it often scrolls before the page\n        // is displayed.\n        requestAnimationFrame(function() {\n          scrollTo(0, offset);\n        });\n      }\n      else {\n        scrollTo(0, offset);\n        // Safari on macOS scrolls before the page is visually changed, but\n        // adding `requestAnimationFrame` doesn't fix it in this case.\n      }\n\n      clearCurrentPageTimeouts();\n\n      $currentLocationWithoutHash = removeHash(urlToPush);\n\n      if ($currentLocationWithoutHash in $windowEventListeners) {\n        $windowEventListeners[$currentLocationWithoutHash] = [];\n      }\n\n      $timers[$currentLocationWithoutHash] = {};\n\n      applyScriptElements(function(element) {\n        return !element.hasAttribute('data-instant-track')\n      });\n\n      triggerPageEvent('change', false);\n    }\n    else {\n      // On popstate, browsers scroll by themselves, but at least Firefox\n      // scrolls BEFORE popstate is fired and thus before we can replace the\n      // page. If the page before popstate is too short the user won't be\n      // scrolled at the right position as a result. We need to scroll again.\n      scrollTo(0, scrollPosition);\n\n      // iOS's gesture to go back by swiping from the left edge of the screen\n      // will start a preloading if the user touches a link, it needs to be\n      // cancelled otherwise the page behind the touched link will be\n      // displayed.\n      $xhr.abort();\n      setPreloadingAsHalted();\n\n      applyScriptElements(function(element) {\n        return element.hasAttribute('data-instant-restore')\n      });\n\n      restoreTimers();\n\n      triggerPageEvent('restore');\n    }\n  }\n\n  function setPreloadingAsHalted() {\n    $isPreloading = false;\n    $isWaitingForCompletion = false;\n  }\n\n  function removeNoscriptTags(html) {\n    // Must be done on text, not on a node's innerHTML, otherwise strange\n    // things happen with implicitly closed elements (see the Noscript test).\n    return html.replace(/<noscript[\\s\\S]+?<\\/noscript>/gi, '')\n  }\n\n  function abortCurrentPageXhrs() {\n    for (var i = 0; i < $currentPageXhrs.length; i++) {\n      if (typeof $currentPageXhrs[i] == 'object' && 'abort' in $currentPageXhrs[i]) {\n        $currentPageXhrs[i].instantclickAbort = true;\n        $currentPageXhrs[i].abort();\n      }\n    }\n    $currentPageXhrs = [];\n  }\n\n  function clearCurrentPageTimeouts() {\n    for (var i in $timers[$currentLocationWithoutHash]) {\n      var timeout = $timers[$currentLocationWithoutHash][i];\n      window.clearTimeout(timeout.realId);\n      timeout.delayLeft = timeout.delay - +new Date + timeout.timestamp;\n    }\n  }\n\n  function restoreTimers() {\n    for (var i in $timers[$currentLocationWithoutHash]) {\n      if (!('delayLeft' in $timers[$currentLocationWithoutHash][i])) {\n        continue\n      }\n      var args = [\n        $timers[$currentLocationWithoutHash][i].callback,\n        $timers[$currentLocationWithoutHash][i].delayLeft\n      ];\n      for (var j = 0; j < $timers[$currentLocationWithoutHash][i].params.length; j++) {\n        args.push($timers[$currentLocationWithoutHash][i].params[j]);\n      }\n      addTimer(args, $timers[$currentLocationWithoutHash][i].isRepeating, $timers[$currentLocationWithoutHash][i].delay);\n      delete $timers[$currentLocationWithoutHash][i];\n    }\n  }\n\n  function handleTouchendWithoutClick() {\n    $xhr.abort();\n    setPreloadingAsHalted();\n  }\n\n  function addOrRemoveWindowEventListeners(addOrRemove) {\n    if ($currentLocationWithoutHash in $windowEventListeners) {\n      for (var i = 0; i < $windowEventListeners[$currentLocationWithoutHash].length; i++) {\n        window[addOrRemove + 'EventListener'].apply(window, $windowEventListeners[$currentLocationWithoutHash][i]);\n      }\n    }\n  }\n\n  function applyScriptElements(condition) {\n    var scriptElementsInDOM = document.body.getElementsByTagName('script')\n      , scriptElementsToCopy = []\n      , originalElement\n      , copyElement\n      , parentNode\n      , nextSibling\n      , i;\n\n    // `scriptElementsInDOM` will change during the copy of scripts if\n    // a script add or delete script elements, so we need to put script\n    // elements in an array to loop through them correctly.\n    for (i = 0; i < scriptElementsInDOM.length; i++) {\n      scriptElementsToCopy.push(scriptElementsInDOM[i]);\n    }\n\n    for (i = 0; i < scriptElementsToCopy.length; i++) {\n      originalElement = scriptElementsToCopy[i];\n      if (!originalElement) { // Might have disappeared, see previous comment\n        continue\n      }\n      if (!condition(originalElement)) {\n        continue\n      }\n\n      copyElement = document.createElement('script');\n      for (var j = 0; j < originalElement.attributes.length; j++) {\n        copyElement.setAttribute(originalElement.attributes[j].name, originalElement.attributes[j].value);\n      }\n      copyElement.textContent = originalElement.textContent;\n\n      parentNode = originalElement.parentNode;\n      nextSibling = originalElement.nextSibling;\n      parentNode.removeChild(originalElement);\n      parentNode.insertBefore(copyElement, nextSibling);\n    }\n  }\n\n  function addTrackedElements() {\n    var trackedElements = document.querySelectorAll('[data-instant-track]')\n      , element\n      , elementData;\n    for (var i = 0; i < trackedElements.length; i++) {\n      element = trackedElements[i];\n      elementData = element.getAttribute('href') || element.getAttribute('src') || element.textContent;\n      // We can't use just `element.href` and `element.src` because we can't\n      // retrieve `href`s and `src`s from the Ajax response.\n      $trackedElementsData.push(elementData);\n    }\n  }\n\n  function addTimer(args, isRepeating, realDelay) {\n    var callback = args[0]\n      , delay = args[1]\n      , params = [].slice.call(args, 2)\n      , timestamp = +new Date;\n\n    $lastUsedTimeoutId++;\n    var id = $lastUsedTimeoutId;\n\n    var callbackModified;\n    if (isRepeating) {\n      callbackModified = function(args2) {\n        callback(args2);\n        delete $timers[$currentLocationWithoutHash][id];\n        args[0] = callback;\n        args[1] = delay;\n        addTimer(args, true);\n      };\n    }\n    else {\n      callbackModified = function(args2) {\n        callback(args2);\n        delete $timers[$currentLocationWithoutHash][id];\n      };\n    }\n\n    args[0] = callbackModified;\n    if (realDelay != undefined) {\n      timestamp += delay - realDelay;\n      delay = realDelay;\n    }\n    var realId = window.setTimeout.apply(window, args);\n    $timers[$currentLocationWithoutHash][id] = {\n      realId: realId,\n      timestamp: timestamp,\n      callback: callback,\n      delay: delay,\n      params: params,\n      isRepeating: isRepeating\n    };\n    return -id\n  }\n\n\n  ////////// EVENT LISTENERS //////////\n\n\n  function mousedownListener(event) {\n    var linkElement = getParentLinkElement(event.target);\n\n    if (!linkElement || !isPreloadable(linkElement)) {\n      return\n    }\n\n    preload(linkElement.href);\n  }\n\n  function mouseoverListener(event) {\n    if ($lastTouchTimestamp > (+new Date - 500)) {\n      // On a touch device, if the content of the page change on mouseover\n      // click is never fired and the user will need to tap a second time.\n      // https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html#//apple_ref/doc/uid/TP40006511-SW4\n      //\n      // Content change could happen in the `preload` event, so we stop there.\n      return\n    }\n\n    if (+new Date - $lastDisplayTimestamp < 100) {\n      // After a page is displayed, if the user's cursor happens to be above\n      // a link a mouseover event will be in most browsers triggered\n      // automatically, and in other browsers it will be triggered when the\n      // user moves his mouse by 1px.\n      //\n      // Here are the behaviors I noticed, all on Windows:\n      // - Safari 5.1: auto-triggers after 0 ms\n      // - IE 11: auto-triggers after 30-80 ms (depends on page's size?)\n      // - Firefox: auto-triggers after 10 ms\n      // - Opera 18: auto-triggers after 10 ms\n      //\n      // - Chrome: triggers when cursor moved\n      // - Opera 12.16: triggers when cursor moved\n      //\n      // To remedy to this, we do nothing if the last display occurred less\n      // than 100 ms ago.\n\n      return\n    }\n\n    var linkElement = getParentLinkElement(event.target);\n\n    if (!linkElement) {\n      return\n    }\n\n    if (linkElement == getParentLinkElement(event.relatedTarget)) {\n      // Happens when mouseout-ing and mouseover-ing child elements of the same link element\n      return\n    }\n\n    if (!isPreloadable(linkElement)) {\n      return\n    }\n\n    linkElement.addEventListener('mouseout', mouseoutListener);\n\n    if (!$isWaitingForCompletion) {\n      $urlToPreload = linkElement.href;\n      $preloadTimer = setTimeout(preload, $delayBeforePreload);\n    }\n  }\n\n  function touchstartListener(event) {\n    $lastTouchTimestamp = +new Date;\n\n    var linkElement = getParentLinkElement(event.target);\n\n    if (!linkElement || !isPreloadable(linkElement)) {\n      return\n    }\n\n    if ($touchEndedWithoutClickTimer) {\n      clearTimeout($touchEndedWithoutClickTimer);\n      $touchEndedWithoutClickTimer = false;\n    }\n\n    linkElement.addEventListener('touchend', touchendAndTouchcancelListener);\n    linkElement.addEventListener('touchcancel', touchendAndTouchcancelListener);\n\n    preload(linkElement.href);\n  }\n\n  function clickListenerPrelude() {\n    // Makes clickListener be fired after everyone else, so that we can respect\n    // event.preventDefault.\n    document.addEventListener('click', clickListener);\n  }\n\n  function clickListener(event) {\n    document.removeEventListener('click', clickListener);\n\n    if ($touchEndedWithoutClickTimer) {\n      clearTimeout($touchEndedWithoutClickTimer);\n      $touchEndedWithoutClickTimer = false;\n    }\n\n    if (event.defaultPrevented) {\n      return\n    }\n\n    var linkElement = getParentLinkElement(event.target);\n\n    if (!linkElement || !isPreloadable(linkElement)) {\n      return\n    }\n\n    // Check if it's opening in a new tab\n    if (event.button != 0 // Chrome < 55 fires a click event when the middle mouse button is pressed\n      || event.metaKey\n      || event.ctrlKey) {\n      return\n    }\n    event.preventDefault();\n    display(linkElement.href);\n  }\n\n  function mouseoutListener(event) {\n    if (getParentLinkElement(event.target) == getParentLinkElement(event.relatedTarget)) {\n      // Happens when mouseout-ing and mouseover-ing child elements of the same link element,\n      // we don't want to stop preloading then.\n      return\n    }\n\n    if ($preloadTimer) {\n      clearTimeout($preloadTimer);\n      $preloadTimer = false;\n      return\n    }\n\n    if (!$isPreloading || $isWaitingForCompletion) {\n      return\n    }\n\n    $xhr.abort();\n    setPreloadingAsHalted();\n  }\n\n  function touchendAndTouchcancelListener(event) {\n    if (!$isPreloading || $isWaitingForCompletion) {\n      return\n    }\n\n    $touchEndedWithoutClickTimer = setTimeout(handleTouchendWithoutClick, 500);\n  }\n\n  function readystatechangeListener() {\n    if ($xhr.readyState == 2) { // headers received\n      var contentType = $xhr.getResponseHeader('Content-Type');\n      if (!contentType || !/^text\\/html/i.test(contentType)) {\n        $isContentTypeNotHTML = true;\n      }\n    }\n\n    if ($xhr.readyState < 4) {\n      return\n    }\n\n    if ($xhr.status == 0) {\n      // Request error/timeout/abort\n      $gotANetworkError = true;\n      if ($isWaitingForCompletion) {\n        triggerPageEvent('exit', $url, 'network error');\n        location.href = $url;\n      }\n      return\n    }\n\n    if ($isContentTypeNotHTML) {\n      if ($isWaitingForCompletion) {\n        triggerPageEvent('exit', $url, 'non-html content-type');\n        location.href = $url;\n      }\n      return\n    }\n\n    var doc = document.implementation.createHTMLDocument('');\n    doc.documentElement.innerHTML = removeNoscriptTags($xhr.responseText);\n    $title = doc.title;\n    $body = doc.body;\n\n    var alteredOnReceive = triggerPageEvent('receive', $url, $body, $title);\n    if (alteredOnReceive) {\n      if ('body' in alteredOnReceive) {\n        $body = alteredOnReceive.body;\n      }\n      if ('title' in alteredOnReceive) {\n        $title = alteredOnReceive.title;\n      }\n    }\n\n    var urlWithoutHash = removeHash($url);\n    $history[urlWithoutHash] = {\n      body: $body,\n      title: $title,\n      scrollPosition: urlWithoutHash in $history ? $history[urlWithoutHash].scrollPosition : 0\n    };\n\n    var trackedElements = doc.querySelectorAll('[data-instant-track]')\n      , element\n      , elementData;\n\n    if (trackedElements.length != $trackedElementsData.length) {\n      $areTrackedElementsDifferent = true;\n    }\n    else {\n      for (var i = 0; i < trackedElements.length; i++) {\n        element = trackedElements[i];\n        elementData = element.getAttribute('href') || element.getAttribute('src') || element.textContent;\n        if ($trackedElementsData.indexOf(elementData) == -1) {\n          $areTrackedElementsDifferent = true;\n        }\n      }\n    }\n\n    if ($isWaitingForCompletion) {\n      $isWaitingForCompletion = false;\n      display($url);\n    }\n  }\n\n  function popstateListener() {\n    var loc = removeHash(location.href);\n    if (loc == $currentLocationWithoutHash) {\n      return\n    }\n\n    if ($isWaitingForCompletion) {\n      setPreloadingAsHalted();\n      $xhr.abort();\n    }\n\n    if (!(loc in $history)) {\n      triggerPageEvent('exit', location.href, 'not in history');\n      if (loc == location.href) { // no location.hash\n        location.href = location.href;\n        // Reloads the page while using cache for scripts, styles and images,\n        // unlike `location.reload()`\n      }\n      else {\n        // When there's a hash, `location.href = location.href` won't reload\n        // the page (but will trigger a popstate event, thus causing an infinite\n        // loop), so we need to call `location.reload()`\n        location.reload();\n      }\n      return\n    }\n\n    $history[$currentLocationWithoutHash].scrollPosition = pageYOffset;\n    clearCurrentPageTimeouts();\n    addOrRemoveWindowEventListeners('remove');\n    $currentLocationWithoutHash = loc;\n    changePage($history[loc].title, $history[loc].body, false, $history[loc].scrollPosition);\n    addOrRemoveWindowEventListeners('add');\n  }\n\n\n  ////////// MAIN FUNCTIONS //////////\n\n\n  function preload(url) {\n    if ($preloadTimer) {\n      clearTimeout($preloadTimer);\n      $preloadTimer = false;\n    }\n\n    if (!url) {\n      url = $urlToPreload;\n    }\n\n    if ($isPreloading && (url == $url || $isWaitingForCompletion)) {\n      return\n    }\n    $isPreloading = true;\n    $isWaitingForCompletion = false;\n\n    $url = url;\n    $body = false;\n    $isContentTypeNotHTML = false;\n    $gotANetworkError = false;\n    $areTrackedElementsDifferent = false;\n    triggerPageEvent('preload');\n    $xhr.open('GET', url);\n    $xhr.timeout = 90000; // Must be set after `open()` with IE\n    $xhr.send();\n  }\n\n  function display(url) {\n    $lastDisplayTimestamp = +new Date;\n    if ($preloadTimer || !$isPreloading) {\n      // $preloadTimer:\n      // Happens when there's a delay before preloading and that delay\n      // hasn't expired (preloading didn't kick in).\n      //\n      // !$isPreloading:\n      // A link has been clicked, and preloading hasn't been initiated.\n      // It happens with touch devices when a user taps *near* the link,\n      // causing `touchstart` not to be fired. Safari/Chrome will trigger\n      // `mouseover`, `mousedown`, `click` (and others), but when that happens\n      // we do nothing in `mouseover` as it may cause `click` not to fire (see\n      // comment in `mouseoverListener`).\n      //\n      // It also happens when a user uses his keyboard to navigate (with Tab\n      // and Return), and possibly in other non-mainstream ways to navigate\n      // a website.\n\n      if ($preloadTimer && $url && $url != url) {\n        // Happens when the user clicks on a link before preloading\n        // kicks in while another link is already preloading.\n\n        triggerPageEvent('exit', url, 'click occured while preloading planned');\n        location.href = url;\n        return\n      }\n\n      preload(url);\n      triggerPageEvent('wait');\n      $isWaitingForCompletion = true; // Must be set *after* calling `preload`\n      return\n    }\n    if ($isWaitingForCompletion) {\n      // The user clicked on a link while a page to display was preloading.\n      // Either on the same link or on another link. If it's the same link\n      // something might have gone wrong (or he could have double clicked, we\n      // don't handle that case), so we send him to the page without pjax.\n      // If it's another link, it hasn't been preloaded, so we redirect the\n      // user to it.\n      triggerPageEvent('exit', url, 'clicked on a link while waiting for another page to display');\n      location.href = url;\n      return\n    }\n    if ($isContentTypeNotHTML) {\n      triggerPageEvent('exit', $url, 'non-html content-type');\n      location.href = $url;\n      return\n    }\n    if ($gotANetworkError) {\n      triggerPageEvent('exit', $url, 'network error');\n      location.href = $url;\n      return\n    }\n    if ($areTrackedElementsDifferent) {\n      triggerPageEvent('exit', $url, 'different assets');\n      location.href = $url;\n      return\n    }\n    if (!$body) {\n      triggerPageEvent('wait');\n      $isWaitingForCompletion = true;\n      return\n    }\n    $history[$currentLocationWithoutHash].scrollPosition = pageYOffset;\n    setPreloadingAsHalted();\n    changePage($title, $body, $url);\n  }\n\n\n  ////////// PUBLIC VARIABLE AND FUNCTIONS //////////\n\n\n  var supported = false;\n  if ('pushState' in history\n      && location.protocol != \"file:\") {\n    supported = true;\n\n    var indexOfAndroid = $userAgent.indexOf('Android ');\n    if (indexOfAndroid > -1) {\n      // The stock browser in Android 4.0.3 through 4.3.1 supports pushState,\n      // though it doesn't update the address bar.\n      //\n      // More problematic is that it has a bug on `popstate` when coming back\n      // from a page not displayed through InstantClick: `location.href` is\n      // undefined and `location.reload()` doesn't work.\n      //\n      // Android < 4.4 is therefore blacklisted, unless it's a browser known\n      // not to have that latter bug.\n\n      var androidVersion = parseFloat($userAgent.substr(indexOfAndroid + 'Android '.length));\n      if (androidVersion < 4.4) {\n        supported = false;\n        if (androidVersion >= 4) {\n          var whitelistedBrowsersUserAgentsOnAndroid4 = [\n            / Chrome\\//, // Chrome, Opera, Puffin, QQ, Yandex\n            / UCBrowser\\//,\n            / Firefox\\//,\n            / Windows Phone / ];\n          for (var i = 0; i < whitelistedBrowsersUserAgentsOnAndroid4.length; i++) {\n            if (whitelistedBrowsersUserAgentsOnAndroid4[i].test($userAgent)) {\n              supported = true;\n              break\n            }\n          }\n        }\n      }\n    }\n  }\n\n  function init(preloadingMode) {\n    if (!supported) {\n      triggerPageEvent('change', true);\n      return\n    }\n\n    if ($hasBeenInitialized) {\n      return\n    }\n    $hasBeenInitialized = true;\n\n    if (preloadingMode == 'mousedown') {\n      $preloadOnMousedown = true;\n    }\n    else if (typeof preloadingMode == 'number') {\n      $delayBeforePreload = preloadingMode;\n    }\n\n    $currentLocationWithoutHash = removeHash(location.href);\n    $timers[$currentLocationWithoutHash] = {};\n    $history[$currentLocationWithoutHash] = {\n      body: document.body,\n      title: document.title,\n      scrollPosition: pageYOffset\n    };\n\n    if (document.readyState == 'loading') {\n      document.addEventListener('DOMContentLoaded', addTrackedElements);\n    }\n    else {\n      addTrackedElements();\n    }\n\n    $xhr = new XMLHttpRequest();\n    $xhr.addEventListener('readystatechange', readystatechangeListener);\n\n    document.addEventListener('touchstart', touchstartListener, true);\n    if ($preloadOnMousedown) {\n      document.addEventListener('mousedown', mousedownListener, true);\n    }\n    else {\n      document.addEventListener('mouseover', mouseoverListener, true);\n    }\n    document.addEventListener('click', clickListenerPrelude, true);\n\n    addEventListener('popstate', popstateListener);\n  }\n\n  function on(eventType, callback) {\n    $eventsCallbacks[eventType].push(callback);\n\n    if (eventType == 'change') {\n      callback(!$lastDisplayTimestamp);\n    }\n  }\n\n  function setTimeout() {\n    return addTimer(arguments, false)\n  }\n\n  function setInterval() {\n    return addTimer(arguments, true)\n  }\n\n  function clearTimeout(id) {\n    id = -id;\n    for (var loc in $timers) {\n      if (id in $timers[loc]) {\n        window.clearTimeout($timers[loc][id].realId);\n        delete $timers[loc][id];\n      }\n    }\n  }\n\n  function xhr(xhr) {\n    $currentPageXhrs.push(xhr);\n  }\n\n  function addPageEvent() {\n    if (!($currentLocationWithoutHash in $windowEventListeners)) {\n      $windowEventListeners[$currentLocationWithoutHash] = [];\n    }\n    $windowEventListeners[$currentLocationWithoutHash].push(arguments);\n    addEventListener.apply(window, arguments);\n  }\n\n  function removePageEvent() {\n    var arguments$1 = arguments;\n\n    if (!($currentLocationWithoutHash in $windowEventListeners)) {\n      return\n    }\n    firstLoop:\n    for (var i = 0; i < $windowEventListeners[$currentLocationWithoutHash].length; i++) {\n      if (arguments$1.length != $windowEventListeners[$currentLocationWithoutHash][i].length) {\n        continue\n      }\n      for (var j = 0; j < $windowEventListeners[$currentLocationWithoutHash][i].length; j++) {\n        if (arguments$1[j] != $windowEventListeners[$currentLocationWithoutHash][i][j]) {\n          continue firstLoop\n        }\n      }\n      $windowEventListeners[$currentLocationWithoutHash].splice(i, 1);\n    }\n  }\n\n  function addEvent(selector, type, listener) {\n    if (!(type in $delegatedEvents)) {\n      $delegatedEvents[type] = {};\n\n      document.addEventListener(type, function(event) {\n        var element = event.target;\n        event.originalStopPropagation = event.stopPropagation;\n        event.stopPropagation = function() {\n          this.isPropagationStopped = true;\n          this.originalStopPropagation();\n        };\n        while (element && element.nodeType == 1) {\n          for (var selector in $delegatedEvents[type]) {\n            if (element.matches(selector)) {\n              for (var i = 0; i < $delegatedEvents[type][selector].length; i++) {\n                $delegatedEvents[type][selector][i].call(element, event);\n              }\n              if (event.isPropagationStopped) {\n                return\n              }\n              break\n            }\n          }\n          element = element.parentNode;\n        }\n      }, false); // Third parameter isn't optional in Firefox < 6\n\n      if (type == 'click' && /iP(?:hone|ad|od)/.test($userAgent)) {\n        // Force Mobile Safari to trigger the click event on document by adding a pointer cursor to body\n\n        var styleElement = document.createElement('style');\n        styleElement.setAttribute('instantclick-mobile-safari-cursor', ''); // So that this style element doesn't surprise developers in the browser DOM inspector.\n        styleElement.textContent = 'body { cursor: pointer !important; }';\n        document.head.appendChild(styleElement);\n      }\n    }\n\n    if (!(selector in $delegatedEvents[type])) {\n      $delegatedEvents[type][selector] = [];\n    }\n\n    // Run removeEvent beforehand so that it can't be added twice\n    removeEvent(selector, type, listener);\n\n    $delegatedEvents[type][selector].push(listener);\n  }\n\n  function removeEvent(selector, type, listener) {\n    var index = $delegatedEvents[type][selector].indexOf(listener);\n    if (index > -1) {\n      $delegatedEvents[type][selector].splice(index, 1);\n    }\n  }\n\n\n  ////////////////////\n\n\n  return {\n    supported: supported,\n    init: init,\n    on: on,\n    setTimeout: setTimeout,\n    setInterval: setInterval,\n    clearTimeout: clearTimeout,\n    xhr: xhr,\n    addPageEvent: addPageEvent,\n    removePageEvent: removePageEvent,\n    addEvent: addEvent,\n    removeEvent: removeEvent\n  }\n\n}(document, location, navigator.userAgent);\n\nreturn InstantClick;\n\n})));\n","/*\n * Loading attribute polyfill - https://github.com/mfranzke/loading-attribute-polyfill\n * @license Copyright(c) 2019 by Maximilian Franzke\n * Credits for the initial kickstarter / script to @Sora2455, and supported by @cbirdsong, @eklingen, @DaPo, @nextgenthemes, @diogoterremoto, @dracos, @Flimm, @TomS- and @vinyfc93 - many thanks for that !\n */\n/*\n * A minimal and dependency-free vanilla JavaScript loading attribute polyfill.\n * Supports standard's functionality and tests for native support upfront.\n * Elsewhere the functionality gets emulated with the support of noscript wrapper tags.\n * Use an IntersectionObserver polyfill in case of IE11 support necessary.\n */\n\n(function (noscriptClass, rootMargin) {\n\t'use strict';\n\n\tvar config = {\n\t\t// Start download if the item gets within 256px in the Y axis\n\t\trootMargin: rootMargin || '0px 0px 256px 0px',\n\t\tthreshold: 0.01,\n\t\tlazyImage: 'img[loading=\"lazy\"]',\n\t\tlazyIframe: 'iframe[loading=\"lazy\"]'\n\t};\n\n\t// Device/browser capabilities object\n\tvar capabilities = {\n\t\tloading:\n\t\t\t'loading' in HTMLImageElement.prototype &&\n\t\t\t'loading' in HTMLIFrameElement.prototype,\n\t\tscrolling: 'onscroll' in window\n\t};\n\n\t// Nodelist foreach polyfill / source: https://stackoverflow.com/a/46929259\n\tif (\n\t\ttypeof NodeList !== 'undefined' &&\n\t\tNodeList.prototype &&\n\t\t!NodeList.prototype.forEach\n\t) {\n\t\t// Yes, there's really no need for `Object.defineProperty` here\n\t\tNodeList.prototype.forEach = Array.prototype.forEach;\n\t}\n\n\t// Define according to browsers support of the IntersectionObserver feature (missing e.g. on IE11 or Safari 11)\n\tvar intersectionObserver;\n\n\tif ('IntersectionObserver' in window) {\n\t\tintersectionObserver = new IntersectionObserver(onIntersection, config);\n\t}\n\n\t// On using a browser w/o requestAnimationFrame support (IE9, Opera Mini), just run the passed function\n\tvar rAFWrapper;\n\n\tif ('requestAnimationFrame' in window) {\n\t\trAFWrapper = window.requestAnimationFrame;\n\t} else {\n\t\trAFWrapper = function (func) {\n\t\t\tfunc();\n\t\t};\n\t}\n\n\t/**\n\t * Put the source and srcset back where it belongs - now that the elements content is attached to the document, it will load now\n\t * @param {Object} lazyItem Current item to be restored after lazy loading.\n\t */\n\tfunction restoreSource(lazyItem) {\n\t\tvar srcsetItems = [];\n\n\t\t// Just in case the img is the decendent of a picture element, check for source tags\n\t\tif (lazyItem.parentNode.tagName.toLowerCase() === 'picture') {\n\t\t\tremovePlaceholderSource(lazyItem.parentNode);\n\n\t\t\tsrcsetItems = Array.prototype.slice.call(\n\t\t\t\tlazyItem.parentNode.querySelectorAll('source')\n\t\t\t);\n\t\t}\n\n\t\tsrcsetItems.push(lazyItem);\n\n\t\t// Not using .dataset within those upfollowing lines of code for polyfill independent compatibility down to IE9\n\t\tsrcsetItems.forEach(function (item) {\n\t\t\tif (item.hasAttribute('data-lazy-srcset')) {\n\t\t\t\titem.setAttribute('srcset', item.getAttribute('data-lazy-srcset'));\n\t\t\t\titem.removeAttribute('data-lazy-srcset'); // Not using delete .dataset here for compatibility down to IE9\n\t\t\t}\n\t\t});\n\n\t\tlazyItem.setAttribute('src', lazyItem.getAttribute('data-lazy-src'));\n\t\tlazyItem.removeAttribute('data-lazy-src'); // Not using delete .dataset here for compatibility down to IE9\n\t}\n\n\t/**\n\t * Remove the source tag preventing the loading of picture assets\n\t * @param {Object} lazyItemPicture Current <picture> item to be restored after lazy loading.\n\t */\n\tfunction removePlaceholderSource(lazyItemPicture) {\n\t\tvar placeholderSource = lazyItemPicture.querySelector(\n\t\t\t'source[data-lazy-remove]'\n\t\t);\n\n\t\tif (placeholderSource) {\n\t\t\tlazyItemPicture.removeChild(placeholderSource); // Preferred .removeChild over .remove here for IE\n\t\t}\n\t}\n\n\t/**\n\t * Handle IntersectionObservers callback\n\t * @param {Object} entries Target elements Intersection observed changes\n\t * @param {Object} observer IntersectionObserver instance reference\n\t */\n\tfunction onIntersection(entries, observer) {\n\t\tentries.forEach(function (entry) {\n\t\t\t// Mitigation for EDGE lacking support of .isIntersecting until v15, compare to e.g. https://github.com/w3c/IntersectionObserver/issues/211#issuecomment-309144669\n\t\t\tif (entry.intersectionRatio === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If the item is visible now, load it and stop watching it\n\t\t\tvar lazyItem = entry.target;\n\n\t\t\tobserver.unobserve(lazyItem);\n\n\t\t\trestoreSource(lazyItem);\n\t\t});\n\t}\n\n\t/**\n\t * Handle printing the page\n\t */\n\tfunction onPrinting() {\n\t\tif (typeof window.matchMedia === 'undefined') {\n\t\t\treturn;\n\t\t}\n\n\t\tvar mediaQueryList = window.matchMedia('print');\n\n\t\tmediaQueryList.addListener(function (mql) {\n\t\t\tif (mql.matches) {\n\t\t\t\tdocument\n\t\t\t\t\t.querySelectorAll(\n\t\t\t\t\t\tconfig.lazyImage +\n\t\t\t\t\t\t\t'[data-lazy-src],' +\n\t\t\t\t\t\t\tconfig.lazyIframe +\n\t\t\t\t\t\t\t'[data-lazy-src]'\n\t\t\t\t\t)\n\t\t\t\t\t.forEach(function (lazyItem) {\n\t\t\t\t\t\trestoreSource(lazyItem);\n\t\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Get and prepare the HTML code depending on feature detection for both image as well as iframe,\n\t * and if not scrolling supported, because it's a Google or Bing Bot\n\t * @param {String} lazyAreaHtml Noscript inner HTML code that src-urls need to get rewritten\n\t */\n\tfunction getAndPrepareHTMLCode(noScriptTag) {\n\t\t// The contents of a <noscript> tag are treated as text to JavaScript\n\t\tvar lazyAreaHtml = noScriptTag.textContent || noScriptTag.innerHTML;\n\n\t\tvar getImageWidth = lazyAreaHtml.match(/width=['\"](\\d+)['\"]/) || false;\n\t\tvar temporaryImageWidth = getImageWidth[1] || 1;\n\t\tvar getImageHeight = lazyAreaHtml.match(/height=['\"](\\d+)['\"]/) || false;\n\t\tvar temporaryImageHeight = getImageHeight[1] || 1;\n\n\t\tvar temporaryImage =\n\t\t\t'data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 ' +\n\t\t\ttemporaryImageWidth +\n\t\t\t' ' +\n\t\t\ttemporaryImageHeight +\n\t\t\t'%27%3E%3C/svg%3E';\n\n\t\tif (!capabilities.loading && capabilities.scrolling) {\n\t\t\t// Check for IntersectionObserver support\n\t\t\tif (typeof intersectionObserver === 'undefined') {\n\t\t\t\t// Attach abandonned attribute 'lazyload' to the HTML tags on browsers w/o IntersectionObserver being available\n\t\t\t\tlazyAreaHtml = lazyAreaHtml.replace(\n\t\t\t\t\t/(?:\\r\\n|\\r|\\n|\\t| )src=/g,\n\t\t\t\t\t' lazyload=\"1\" src='\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tif (noScriptTag.parentNode.tagName.toLowerCase() === 'picture') {\n\t\t\t\t\t// Temporarily prevent expensive resource loading by inserting a <source> tag pointing to a simple one (data URI)\n\t\t\t\t\tlazyAreaHtml =\n\t\t\t\t\t\t'<source srcset=\"' +\n\t\t\t\t\t\ttemporaryImage +\n\t\t\t\t\t\t'\" data-lazy-remove=\"true\"></source>' +\n\t\t\t\t\t\tlazyAreaHtml;\n\t\t\t\t}\n\n\t\t\t\t// Temporarily replace a expensive resource load with a simple one by storing the actual source and srcset for later and point src to a temporary replacement (data URI)\n\t\t\t\tlazyAreaHtml = lazyAreaHtml\n\t\t\t\t\t.replace(/(?:\\r\\n|\\r|\\n|\\t| )srcset=/g, ' data-lazy-srcset=')\n\t\t\t\t\t.replace(\n\t\t\t\t\t\t/(?:\\r\\n|\\r|\\n|\\t| )src=/g,\n\t\t\t\t\t\t' src=\"' + temporaryImage + '\" data-lazy-src='\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn lazyAreaHtml;\n\t}\n\n\t/**\n\t * Retrieve the elements from the 'lazy load' <noscript> tag and prepare them for display\n\t * @param {Object} noScriptTag noscript HTML tag that should get initially transformed\n\t */\n\tfunction prepareElement(noScriptTag) {\n\t\t// Sticking the noscript HTML code in the innerHTML of a new <div> tag to 'load' it after creating that <div>\n\t\tvar lazyArea = document.createElement('div');\n\n\t\tlazyArea.innerHTML = getAndPrepareHTMLCode(noScriptTag);\n\n\t\t// Move all children out of the element\n\t\twhile (lazyArea.firstChild) {\n\t\t\tif (\n\t\t\t\t!capabilities.loading &&\n\t\t\t\tcapabilities.scrolling &&\n\t\t\t\ttypeof intersectionObserver !== 'undefined' &&\n\t\t\t\tlazyArea.firstChild.tagName &&\n\t\t\t\t(lazyArea.firstChild.tagName.toLowerCase() === 'img' ||\n\t\t\t\t\tlazyArea.firstChild.tagName.toLowerCase() === 'iframe')\n\t\t\t) {\n\t\t\t\t// Observe the item so that loading could start when it gets close to the viewport\n\t\t\t\tintersectionObserver.observe(lazyArea.firstChild);\n\t\t\t}\n\n\t\t\tnoScriptTag.parentNode.insertBefore(lazyArea.firstChild, noScriptTag);\n\t\t}\n\n\t\t// Remove the empty element - not using .remove() here for IE11 compatibility\n\t\tnoScriptTag.parentNode.removeChild(noScriptTag); // Preferred .removeChild over .remove here for IE\n\t}\n\n\t/**\n\t * Get all the <noscript> tags on the page and setup the printing\n\t */\n\tfunction prepareElements() {\n\t\t//\n\t\tvar lazyLoadAreas = document.querySelectorAll('noscript.' + noscriptClass);\n\n\t\tlazyLoadAreas.forEach(prepareElement);\n\n\t\t// Bind for someone printing the page\n\t\tonPrinting();\n\t}\n\n\t// If the page has loaded already, run setup - if it hasn't, run as soon as it has.\n\t// Use requestAnimationFrame as this will propably cause repaints\n\t// document.readyState values: https://www.w3schools.com/jsref/prop_doc_readystate.asp\n\tif (/comp|inter/.test(document.readyState)) {\n\t\trAFWrapper(prepareElements);\n\t} else if ('addEventListener' in document) {\n\t\tdocument.addEventListener('DOMContentLoaded', function () {\n\t\t\trAFWrapper(prepareElements);\n\t\t});\n\t} else {\n\t\tdocument.attachEvent('onreadystatechange', function () {\n\t\t\tif (document.readyState === 'complete') {\n\t\t\t\tprepareElements();\n\t\t\t}\n\t\t});\n\t}\n})('loading-lazy', '256px 0px');\n"],"sourceRoot":""}